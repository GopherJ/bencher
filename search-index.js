var searchIndex = {};
searchIndex["bencher"] = {"doc":"Simplified stable-compatible benchmark runner.","items":[[3,"Bencher","bencher","Manager of the benchmarking runs.",null,null],[12,"bytes","","",0,null],[3,"TestDesc","","",null,null],[12,"name","","",1,null],[12,"ignore","","",1,null],[3,"TestPaths","","",null,null],[12,"file","","",2,null],[12,"base","","",2,null],[12,"relative_dir","","",2,null],[3,"TestDescAndFn","","",null,null],[12,"desc","","",3,null],[12,"testfn","","",3,null],[3,"TestOpts","","",null,null],[12,"filter","","",4,null],[12,"run_ignored","","",4,null],[12,"logfile","","",4,null],[12,"quiet","","",4,null],[12,"test_threads","","",4,null],[3,"BenchSamples","","",null,null],[4,"TestFn","","",null,null],[13,"StaticBenchFn","","",5,null],[13,"DynBenchFn","","",5,null],[5,"fmt_bench_samples","","",null,{"inputs":[{"name":"benchsamples"}],"output":{"name":"string"}}],[5,"run_tests_console","","",null,{"inputs":[{"name":"testopts"},{"name":"vec"}],"output":{"name":"result"}}],[5,"black_box","","WARNING: We don&#39;t have a proper black box in stable Rust. This is\na workaround implementation, that may have a too big performance overhead,\ndepending on operation, or it may fail to properly avoid having code optimized out.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[0,"stats","","",null,null],[3,"Summary","bencher::stats","Extracted collection of all the summary statistics of a sample set.",null,null],[12,"sum","","",6,null],[12,"min","","",6,null],[12,"max","","",6,null],[12,"mean","","",6,null],[12,"median","","",6,null],[12,"var","","",6,null],[12,"std_dev","","",6,null],[12,"std_dev_pct","","",6,null],[12,"median_abs_dev","","",6,null],[12,"median_abs_dev_pct","","",6,null],[12,"quartiles","","",6,null],[12,"iqr","","",6,null],[5,"winsorize","","Winsorize a set of samples, replacing values above the `100-pct` percentile\nand below the `pct` percentile with those percentiles themselves. This is a\nway of minimizing the effect of outliers, at the cost of biasing the sample.\nIt differs from trimming in that it does not change the number of samples,\njust changes the values of those that are outliers.",null,null],[8,"Stats","","Trait that provides simple descriptive statistics on a univariate set of numeric samples.",null,null],[10,"sum","","Sum of the samples.",7,null],[10,"min","","Minimum value of the samples.",7,null],[10,"max","","Maximum value of the samples.",7,null],[10,"mean","","Arithmetic mean (average) of the samples: sum divided by sample-count.",7,null],[10,"median","","Median of the samples: value separating the lower half of the samples from the higher half.\nEqual to `self.percentile(50.0)`.",7,null],[10,"var","","Variance of the samples: bias-corrected mean of the squares of the differences of each\nsample from the sample mean. Note that this calculates the _sample variance_ rather than the\npopulation variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\nbias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\nthan `n`.",7,null],[10,"std_dev","","Standard deviation: the square root of the sample variance.",7,null],[10,"std_dev_pct","","Standard deviation as a percent of the mean value. See `std_dev` and `mean`.",7,null],[10,"median_abs_dev","","Scaled median of the absolute deviations of each sample from the sample median. This is a\nrobust (distribution-agnostic) estimator of sample variability. Use this in preference to\n`std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\nby the constant `1.4826` to allow its use as a consistent estimator for the standard\ndeviation.",7,null],[10,"median_abs_dev_pct","","Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.",7,null],[10,"percentile","","Percentile: the value below which `pct` percent of the values in `self` fall. For example,\npercentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\nsatisfy `s &lt;= v`.",7,null],[10,"quartiles","","Quartiles of the sample: three values that divide the sample into four equal groups, each\nwith 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\nfunction may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\nis otherwise equivalent.",7,null],[10,"iqr","","Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\npercentile (3rd quartile). See `quartiles`.",7,null],[11,"clone","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"new","","Construct a new summary of a sample set.",6,null],[0,"bench","bencher","",null,null],[5,"benchmark","bencher::bench","",null,{"inputs":[{"name":"f"}],"output":{"name":"benchsamples"}}],[5,"run_once","","",null,{"inputs":[{"name":"f"}],"output":null}],[6,"TestName","bencher","",null,null],[8,"TDynBenchFn","","Represents a benchmark function.",null,null],[10,"run","","",8,null],[11,"fmt","","",5,null],[11,"clone","","",0,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"hash","","",1,null],[11,"clone","","",2,null],[11,"fmt","","",3,null],[11,"default","","",4,{"inputs":[],"output":{"name":"testopts"}}],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"iter","","Callback for benchmark functions to run in their body.",0,null],[11,"ns_elapsed","","",0,null],[11,"ns_per_iter","","",0,null],[11,"bench_n","","",0,null],[11,"auto_bench","","",0,null],[14,"benchmark_group","","Defines a function called `$group_name` that returns the test description\nvalues for the listed functions `$function`.",null,null],[14,"benchmark_main","","Define a `fn main()` that will run all benchmarks defined by the groups\nin `$group_name`.",null,null]],"paths":[[3,"Bencher"],[3,"TestDesc"],[3,"TestPaths"],[3,"TestDescAndFn"],[3,"TestOpts"],[4,"TestFn"],[3,"Summary"],[8,"Stats"],[8,"TDynBenchFn"],[3,"BenchSamples"]]};
initSearch(searchIndex);
